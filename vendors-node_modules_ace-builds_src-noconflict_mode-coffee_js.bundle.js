/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkrobot_karol_4"] = self["webpackChunkrobot_karol_4"] || []).push([["vendors-node_modules_ace-builds_src-noconflict_mode-coffee_js"],{

/***/ "./node_modules/ace-builds/src-noconflict/mode-coffee.js":
/*!***************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/mode-coffee.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nace.define(\"ace/mode/coffee_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\noop.inherits(CoffeeHighlightRules, TextHighlightRules);\nfunction CoffeeHighlightRules() {\n    var identifier = \"[$A-Za-z_\\\\x7f-\\\\uffff][$\\\\w\\\\x7f-\\\\uffff]*\";\n    var keywords = (\"this|throw|then|try|typeof|super|switch|return|break|by|continue|\" +\n        \"catch|class|in|instanceof|is|isnt|if|else|extends|for|own|\" +\n        \"finally|function|while|when|new|no|not|delete|debugger|do|loop|of|off|\" +\n        \"or|on|unless|until|and|yes|yield|export|import|default\");\n    var langConstant = (\"true|false|null|undefined|NaN|Infinity\");\n    var illegal = (\"case|const|function|var|void|with|enum|implements|\" +\n        \"interface|let|package|private|protected|public|static\");\n    var supportClass = (\"Array|Boolean|Date|Function|Number|Object|RegExp|ReferenceError|String|\" +\n        \"Error|EvalError|InternalError|RangeError|ReferenceError|StopIteration|\" +\n        \"SyntaxError|TypeError|URIError|\" +\n        \"ArrayBuffer|Float32Array|Float64Array|Int16Array|Int32Array|Int8Array|\" +\n        \"Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray\");\n    var supportFunction = (\"Math|JSON|isNaN|isFinite|parseInt|parseFloat|encodeURI|\" +\n        \"encodeURIComponent|decodeURI|decodeURIComponent|String|\");\n    var variableLanguage = (\"window|arguments|prototype|document\");\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": langConstant,\n        \"invalid.illegal\": illegal,\n        \"language.support.class\": supportClass,\n        \"language.support.function\": supportFunction,\n        \"variable.language\": variableLanguage\n    }, \"identifier\");\n    var functionRule = {\n        token: [\"paren.lparen\", \"variable.parameter\", \"paren.rparen\", \"text\", \"storage.type\"],\n        regex: /(?:(\\()((?:\"[^\")]*?\"|'[^')]*?'|\\/[^\\/)]*?\\/|[^()\"'\\/])*?)(\\))(\\s*))?([\\-=]>)/.source\n    };\n    var stringEscape = /\\\\(?:x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.)/;\n    this.$rules = {\n        start: [\n            {\n                token: \"constant.numeric\",\n                regex: \"(?:0x[\\\\da-fA-F]+|(?:\\\\d+(?:\\\\.\\\\d+)?|\\\\.\\\\d+)(?:[eE][+-]?\\\\d+)?)\"\n            }, {\n                stateName: \"qdoc\",\n                token: \"string\", regex: \"'''\", next: [\n                    { token: \"string\", regex: \"'''\", next: \"start\" },\n                    { token: \"constant.language.escape\", regex: stringEscape },\n                    { defaultToken: \"string\" }\n                ]\n            }, {\n                stateName: \"qqdoc\",\n                token: \"string\",\n                regex: '\"\"\"',\n                next: [\n                    { token: \"string\", regex: '\"\"\"', next: \"start\" },\n                    { token: \"paren.string\", regex: '#{', push: \"start\" },\n                    { token: \"constant.language.escape\", regex: stringEscape },\n                    { defaultToken: \"string\" }\n                ]\n            }, {\n                stateName: \"qstring\",\n                token: \"string\", regex: \"'\", next: [\n                    { token: \"string\", regex: \"'\", next: \"start\" },\n                    { token: \"constant.language.escape\", regex: stringEscape },\n                    { defaultToken: \"string\" }\n                ]\n            }, {\n                stateName: \"qqstring\",\n                token: \"string.start\", regex: '\"', next: [\n                    { token: \"string.end\", regex: '\"', next: \"start\" },\n                    { token: \"paren.string\", regex: '#{', push: \"start\" },\n                    { token: \"constant.language.escape\", regex: stringEscape },\n                    { defaultToken: \"string\" }\n                ]\n            }, {\n                stateName: \"js\",\n                token: \"string\", regex: \"`\", next: [\n                    { token: \"string\", regex: \"`\", next: \"start\" },\n                    { token: \"constant.language.escape\", regex: stringEscape },\n                    { defaultToken: \"string\" }\n                ]\n            }, {\n                regex: \"[{}]\", onMatch: function (val, state, stack) {\n                    this.next = \"\";\n                    if (val == \"{\" && stack.length) {\n                        stack.unshift(\"start\", state);\n                        return \"paren\";\n                    }\n                    if (val == \"}\" && stack.length) {\n                        stack.shift();\n                        this.next = stack.shift() || \"\";\n                        if (this.next.indexOf(\"string\") != -1)\n                            return \"paren.string\";\n                    }\n                    return \"paren\";\n                }\n            }, {\n                token: \"string.regex\",\n                regex: \"///\",\n                next: \"heregex\"\n            }, {\n                token: \"string.regex\",\n                regex: /(?:\\/(?![\\s=])[^[\\/\\n\\\\]*(?:(?:\\\\[\\s\\S]|\\[[^\\]\\n\\\\]*(?:\\\\[\\s\\S][^\\]\\n\\\\]*)*])[^[\\/\\n\\\\]*)*\\/)(?:[imgy]{0,4})(?!\\w)/\n            }, {\n                token: \"comment\",\n                regex: \"###(?!#)\",\n                next: \"comment\"\n            }, {\n                token: \"comment\",\n                regex: \"#.*\"\n            }, {\n                token: [\"punctuation.operator\", \"text\", \"identifier\"],\n                regex: \"(\\\\.)(\\\\s*)(\" + illegal + \")\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"\\\\.{1,3}\"\n            }, {\n                token: [\"keyword\", \"text\", \"language.support.class\",\n                    \"text\", \"keyword\", \"text\", \"language.support.class\"],\n                regex: \"(class)(\\\\s+)(\" + identifier + \")(?:(\\\\s+)(extends)(\\\\s+)(\" + identifier + \"))?\"\n            }, {\n                token: [\"entity.name.function\", \"text\", \"keyword.operator\", \"text\"].concat(functionRule.token),\n                regex: \"(\" + identifier + \")(\\\\s*)([=:])(\\\\s*)\" + functionRule.regex\n            },\n            functionRule,\n            {\n                token: \"variable\",\n                regex: \"@(?:\" + identifier + \")?\"\n            }, {\n                token: keywordMapper,\n                regex: identifier\n            }, {\n                token: \"punctuation.operator\",\n                regex: \"\\\\,|\\\\.\"\n            }, {\n                token: \"storage.type\",\n                regex: \"[\\\\-=]>\"\n            }, {\n                token: \"keyword.operator\",\n                regex: \"(?:[-+*/%<>&|^!?=]=|>>>=?|\\\\-\\\\-|\\\\+\\\\+|::|&&=|\\\\|\\\\|=|<<=|>>=|\\\\?\\\\.|\\\\.{2,3}|[!*+-=><])\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[({[]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\]})]\"\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }\n        ],\n        heregex: [{\n                token: \"string.regex\",\n                regex: '.*?///[imgy]{0,4}',\n                next: \"start\"\n            }, {\n                token: \"comment.regex\",\n                regex: \"\\\\s+(?:#.*)?\"\n            }, {\n                token: \"string.regex\",\n                regex: \"\\\\S+\"\n            }],\n        comment: [{\n                token: \"comment\",\n                regex: '###',\n                next: \"start\"\n            }, {\n                defaultToken: \"comment\"\n            }]\n    };\n    this.normalizeRules();\n}\nexports.CoffeeHighlightRules = CoffeeHighlightRules;\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar MatchingBraceOutdent = function () { };\n(function () {\n    this.checkOutdent = function (line, input) {\n        if (!/^\\s+$/.test(line))\n            return false;\n        return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n        if (!match)\n            return 0;\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({ row: row, column: column });\n        if (!openBracePos || openBracePos.row == row)\n            return 0;\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n}).call(MatchingBraceOutdent.prototype);\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar FoldMode = exports.FoldMode = function () { };\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.commentBlock = function (session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n            if (level == -1)\n                continue;\n            if (line[level] != \"#\")\n                break;\n            endRow = row;\n        }\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        }\n        else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n        if (prevIndent != -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/coffee\",[\"require\",\"exports\",\"module\",\"ace/mode/coffee_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/mode/folding/coffee\",\"ace/range\",\"ace/mode/text\",\"ace/worker/worker_client\",\"ace/lib/oop\"], function(require, exports, module){\"use strict\";\nvar Rules = require(\"./coffee_highlight_rules\").CoffeeHighlightRules;\nvar Outdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\nvar Range = require(\"../range\").Range;\nvar TextMode = require(\"./text\").Mode;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar oop = require(\"../lib/oop\");\nfunction Mode() {\n    this.HighlightRules = Rules;\n    this.$outdent = new Outdent();\n    this.foldingRules = new FoldMode();\n}\noop.inherits(Mode, TextMode);\n(function () {\n    var indenter = /(?:[({[=:]|[-=]>|\\b(?:else|try|(?:swi|ca)tch(?:\\s+[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*)?|finally))\\s*$|^\\s*(else\\b\\s*)?(?:if|for|while|loop)\\b(?!.*\\bthen\\b)/;\n    this.lineCommentStart = \"#\";\n    this.blockComment = { start: \"###\", end: \"###\" };\n    this.getNextLineIndent = function (state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokens = this.getTokenizer().getLineTokens(line, state).tokens;\n        if (!(tokens.length && tokens[tokens.length - 1].type === 'comment') &&\n            state === 'start' && indenter.test(line))\n            indent += tab;\n        return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n        return this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, doc, row) {\n        this.$outdent.autoOutdent(doc, row);\n    };\n    this.createWorker = function (session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/coffee_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        worker.on(\"annotate\", function (e) {\n            session.setAnnotations(e.data);\n        });\n        worker.on(\"terminate\", function () {\n            session.clearAnnotations();\n        });\n        return worker;\n    };\n    this.$id = \"ace/mode/coffee\";\n    this.snippetFileId = \"ace/snippets/coffee\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/coffee\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n\n//# sourceURL=webpack://robot-karol-4/./node_modules/ace-builds/src-noconflict/mode-coffee.js?");

/***/ })

}]);