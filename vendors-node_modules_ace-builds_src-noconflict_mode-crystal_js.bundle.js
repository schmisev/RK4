/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkrobot_karol_4"] = self["webpackChunkrobot_karol_4"] || []).push([["vendors-node_modules_ace-builds_src-noconflict_mode-crystal_js"],{

/***/ "./node_modules/ace-builds/src-noconflict/mode-crystal.js":
/*!****************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/mode-crystal.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nace.define(\"ace/mode/crystal_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar CrystalHighlightRules = function () {\n    var builtinFunctions = (\"puts|initialize|previous_def|typeof|as|pointerof|sizeof|instance_sizeof\");\n    var keywords = (\"if|end|else|elsif|unless|case|when|break|while|next|until|def|return|class|new|getter|setter|property|lib\"\n        + \"|fun|do|struct|private|protected|public|module|super|abstract|include|extend|begin|enum|raise|yield|with\"\n        + \"|alias|rescue|ensure|macro|uninitialized|union|type|require\");\n    var buildinConstants = (\"true|TRUE|false|FALSE|nil|NIL|__LINE__|__END_LINE__|__FILE__|__DIR__\");\n    var builtinVariables = (\"$DEBUG|$defout|$FILENAME|$LOAD_PATH|$SAFE|$stdin|$stdout|$stderr|$VERBOSE|\" +\n        \"root_url|flash|session|cookies|params|request|response|logger|self\");\n    var keywordMapper = this.$keywords = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"constant.language\": buildinConstants,\n        \"variable.language\": builtinVariables,\n        \"support.function\": builtinFunctions\n    }, \"identifier\");\n    var hexNumber = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var decNumber = \"(?:[0-9][\\\\d_]*)\";\n    var octNumber = \"(?:0o[0-7][0-7]*)\";\n    var binNumber = \"(?:0[bB][01]+)\";\n    var intNumber = \"(?:[+-]?)(?:\" + hexNumber + \"|\" + decNumber + \"|\" + octNumber + \"|\" + binNumber + \")(?:_?[iIuU](?:8|16|32|64))?\\\\b\";\n    var escapeExpression = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}})/;\n    var extEscapeExspresssion = /\\\\(?:[nsrtvfbae'\"\\\\]|[0-7]{3}|x[\\da-fA-F]{2}|u[\\da-fA-F]{4}|u{[\\da-fA-F]{1,6}}|u{(:?[\\da-fA-F]{2}\\s)*[\\da-fA-F]{2}})/;\n    this.$rules = {\n        \"start\": [\n            {\n                token: \"comment\",\n                regex: \"#.*$\"\n            }, {\n                token: \"string.regexp\",\n                regex: \"[/]\",\n                push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"string.regexp\",\n                        regex: \"[/][imx]*(?=[).,;\\\\s]|$)\",\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"string.regexp\"\n                    }]\n            },\n            [{\n                    regex: \"[{}]\", onMatch: function (val, state, stack) {\n                        this.next = val == \"{\" ? this.nextState : \"\";\n                        if (val == \"{\" && stack.length) {\n                            stack.unshift(\"start\", state);\n                            return \"paren.lparen\";\n                        }\n                        if (val == \"}\" && stack.length) {\n                            stack.shift();\n                            this.next = stack.shift();\n                            if (this.next.indexOf(\"string\") != -1)\n                                return \"paren.end\";\n                        }\n                        return val == \"{\" ? \"paren.lparen\" : \"paren.rparen\";\n                    },\n                    nextState: \"start\"\n                }, {\n                    token: \"string.start\",\n                    regex: /\"/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string\",\n                            regex: /\\\\#{/\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /\"/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\",\n                    regex: /`/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string\",\n                            regex: /\\\\#{/\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /`/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"rpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\(/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string.start\",\n                            regex: /\\(/,\n                            push: \"rpstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /\\)/,\n                            next: \"pop\"\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"spstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\[/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string.start\",\n                            regex: /\\[/,\n                            push: \"spstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /]/,\n                            next: \"pop\"\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"fpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?{/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string.start\",\n                            regex: /{/,\n                            push: \"fpstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /}/,\n                            next: \"pop\"\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"tpstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?</,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string.start\",\n                            regex: /</,\n                            push: \"tpstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: />/,\n                            next: \"pop\"\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"ppstring\",\n                    token: \"string.start\",\n                    regex: /%[Qx]?\\|/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: extEscapeExspresssion\n                        }, {\n                            token: \"string.end\",\n                            regex: /\\|/,\n                            next: \"pop\"\n                        }, {\n                            token: \"paren.start\",\n                            regex: /#{/,\n                            push: \"start\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"rpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\(/,\n                    push: [{\n                            token: \"string.start\",\n                            regex: /\\(/,\n                            push: \"rpqstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /\\)/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"spqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\[/,\n                    push: [{\n                            token: \"string.start\",\n                            regex: /\\[/,\n                            push: \"spqstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /]/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"fpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]{/,\n                    push: [{\n                            token: \"string.start\",\n                            regex: /{/,\n                            push: \"fpqstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: /}/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"tpqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]</,\n                    push: [{\n                            token: \"string.start\",\n                            regex: /</,\n                            push: \"tpqstring\"\n                        }, {\n                            token: \"string.end\",\n                            regex: />/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    stateName: \"ppqstring\",\n                    token: \"string.start\",\n                    regex: /%[qwir]\\|/,\n                    push: [{\n                            token: \"string.end\",\n                            regex: /\\|/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }, {\n                    token: \"string.start\",\n                    regex: /'/,\n                    push: [{\n                            token: \"constant.language.escape\",\n                            regex: escapeExpression\n                        }, {\n                            token: \"string.end\",\n                            regex: /'|$/,\n                            next: \"pop\"\n                        }, {\n                            defaultToken: \"string\"\n                        }]\n                }], {\n                token: \"text\", // namespaces aren't symbols\n                regex: \"::\"\n            }, {\n                token: \"variable.instance\", // instance variable\n                regex: \"@{1,2}[a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"variable.fresh\", // fresh variable\n                regex: \"%[a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"support.class\", // class name\n                regex: \"[A-Z][a-zA-Z_\\\\d]+\"\n            }, {\n                token: \"constant.other.symbol\", // symbol\n                regex: \"[:](?:(?:===|<=>|\\\\[]\\\\?|\\\\[]=|\\\\[]|>>|\\\\*\\\\*|<<|==|!=|>=|<=|!~|=~|<|\\\\+|-|\\\\*|\\\\/|%|&|\\\\||\\\\^|>|!|~)|(?:(?:[A-Za-z_]|[@$](?=[a-zA-Z0-9_]))[a-zA-Z0-9_]*[!=?]?))\"\n            }, {\n                token: \"constant.numeric\", // float\n                regex: \"[+-]?\\\\d(?:\\\\d|_(?=\\\\d))*(?:(?:\\\\.\\\\d(?:\\\\d|_(?=\\\\d))*)?(?:[eE][+-]?\\\\d+)?)?(?:_?[fF](?:32|64))?\\\\b\"\n            }, {\n                token: \"constant.numeric\",\n                regex: intNumber\n            }, {\n                token: \"constant.other.symbol\",\n                regex: ':\"',\n                push: [{\n                        token: \"constant.language.escape\",\n                        regex: extEscapeExspresssion\n                    }, {\n                        token: \"constant.other.symbol\",\n                        regex: '\"',\n                        next: \"pop\"\n                    }, {\n                        defaultToken: \"constant.other.symbol\"\n                    }]\n            }, {\n                token: \"constant.language.boolean\",\n                regex: \"(?:true|false)\\\\b\"\n            }, {\n                token: \"support.function\",\n                regex: \"(?:is_a\\\\?|nil\\\\?|responds_to\\\\?|as\\\\?)\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$!?]*\\\\b\"\n            }, {\n                token: \"variable.system\",\n                regex: \"\\\\$\\\\!|\\\\$\\\\?\"\n            }, {\n                token: \"punctuation.separator.key-value\",\n                regex: \"=>\"\n            }, {\n                stateName: \"heredoc\",\n                onMatch: function (value, currentState, stack) {\n                    var next = \"heredoc\";\n                    var tokens = value.split(this.splitRegex);\n                    stack.push(next, tokens[3]);\n                    return [\n                        { type: \"constant\", value: tokens[1] },\n                        { type: \"string\", value: tokens[2] },\n                        { type: \"support.class\", value: tokens[3] },\n                        { type: \"string\", value: tokens[4] }\n                    ];\n                },\n                regex: \"(<<-)([']?)([\\\\w]+)([']?)\",\n                rules: {\n                    heredoc: [{\n                            token: \"string\",\n                            regex: \"^ +\"\n                        }, {\n                            onMatch: function (value, currentState, stack) {\n                                if (value === stack[1]) {\n                                    stack.shift();\n                                    stack.shift();\n                                    this.next = stack[0] || \"start\";\n                                    return \"support.class\";\n                                }\n                                this.next = \"\";\n                                return \"string\";\n                            },\n                            regex: \".*$\",\n                            next: \"start\"\n                        }]\n                }\n            }, {\n                regex: \"$\",\n                token: \"empty\",\n                next: function (currentState, stack) {\n                    if (stack[0] === \"heredoc\")\n                        return stack[0];\n                    return currentState;\n                }\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[.]\\s*(?![.])/,\n                push: [{\n                        token: \"punctuation.operator\",\n                        regex: /[.]\\s*(?![.])/\n                    }, {\n                        token: \"support.function\",\n                        regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n                    }, {\n                        regex: \"\",\n                        token: \"empty\",\n                        next: \"pop\"\n                    }]\n            }, {\n                token: \"keyword.operator\",\n                regex: \"!|\\\\$|%|&|\\\\*|\\\\-\\\\-|\\\\-|\\\\+\\\\+|\\\\+|~|===|==|=|!=|!==|<=|>=|<<=|>>=|>>>=|<>|<|>|!|\\\\?|\\\\:|&&|\\\\|\\\\||\\\\?\\\\:|\\\\*=|%=|\\\\+=|\\\\-=|&=|\\\\^=|\\\\^|\\\\|\"\n            }, {\n                token: \"punctuation.operator\",\n                regex: /[?:,;.]/\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[[({]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\])}]\"\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+\"\n            }\n        ]\n    };\n    this.normalizeRules();\n};\noop.inherits(CrystalHighlightRules, TextHighlightRules);\nexports.CrystalHighlightRules = CrystalHighlightRules;\n\n});\n\nace.define(\"ace/mode/matching_brace_outdent\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar Range = require(\"../range\").Range;\nvar MatchingBraceOutdent = function () { };\n(function () {\n    this.checkOutdent = function (line, input) {\n        if (!/^\\s+$/.test(line))\n            return false;\n        return /^\\s*\\}/.test(input);\n    };\n    this.autoOutdent = function (doc, row) {\n        var line = doc.getLine(row);\n        var match = line.match(/^(\\s*\\})/);\n        if (!match)\n            return 0;\n        var column = match[1].length;\n        var openBracePos = doc.findMatchingBracket({ row: row, column: column });\n        if (!openBracePos || openBracePos.row == row)\n            return 0;\n        var indent = this.$getIndent(doc.getLine(openBracePos.row));\n        doc.replace(new Range(row, 0, row, column - 1), indent);\n    };\n    this.$getIndent = function (line) {\n        return line.match(/^\\s*/)[0];\n    };\n}).call(MatchingBraceOutdent.prototype);\nexports.MatchingBraceOutdent = MatchingBraceOutdent;\n\n});\n\nace.define(\"ace/mode/folding/coffee\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar FoldMode = exports.FoldMode = function () { };\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.commentBlock = function (session, row) {\n        var re = /\\S/;\n        var line = session.getLine(row);\n        var startLevel = line.search(re);\n        if (startLevel == -1 || line[startLevel] != \"#\")\n            return;\n        var startColumn = line.length;\n        var maxRow = session.getLength();\n        var startRow = row;\n        var endRow = row;\n        while (++row < maxRow) {\n            line = session.getLine(row);\n            var level = line.search(re);\n            if (level == -1)\n                continue;\n            if (line[level] != \"#\")\n                break;\n            endRow = row;\n        }\n        if (endRow > startRow) {\n            var endColumn = session.getLine(endRow).length;\n            return new Range(startRow, startColumn, endRow, endColumn);\n        }\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var range = this.indentationBlock(session, row);\n        if (range)\n            return range;\n        range = this.commentBlock(session, row);\n        if (range)\n            return range;\n    };\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var indent = line.search(/\\S/);\n        var next = session.getLine(row + 1);\n        var prev = session.getLine(row - 1);\n        var prevIndent = prev.search(/\\S/);\n        var nextIndent = next.search(/\\S/);\n        if (indent == -1) {\n            session.foldWidgets[row - 1] = prevIndent != -1 && prevIndent < nextIndent ? \"start\" : \"\";\n            return \"\";\n        }\n        if (prevIndent == -1) {\n            if (indent == nextIndent && line[indent] == \"#\" && next[indent] == \"#\") {\n                session.foldWidgets[row - 1] = \"\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"start\";\n            }\n        }\n        else if (prevIndent == indent && line[indent] == \"#\" && prev[indent] == \"#\") {\n            if (session.getLine(row - 2).search(/\\S/) == -1) {\n                session.foldWidgets[row - 1] = \"start\";\n                session.foldWidgets[row + 1] = \"\";\n                return \"\";\n            }\n        }\n        if (prevIndent != -1 && prevIndent < indent)\n            session.foldWidgets[row - 1] = \"start\";\n        else\n            session.foldWidgets[row - 1] = \"\";\n        if (indent < nextIndent)\n            return \"start\";\n        else\n            return \"\";\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/crystal\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/crystal_highlight_rules\",\"ace/mode/matching_brace_outdent\",\"ace/range\",\"ace/mode/folding/coffee\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar CrystalHighlightRules = require(\"./crystal_highlight_rules\").CrystalHighlightRules;\nvar MatchingBraceOutdent = require(\"./matching_brace_outdent\").MatchingBraceOutdent;\nvar Range = require(\"../range\").Range;\nvar FoldMode = require(\"./folding/coffee\").FoldMode;\nvar Mode = function () {\n    this.HighlightRules = CrystalHighlightRules;\n    this.$outdent = new MatchingBraceOutdent();\n    this.$behaviour = this.$defaultBehaviour;\n    this.foldingRules = new FoldMode();\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \"#\";\n    this.getNextLineIndent = function (state, line, tab) {\n        var indent = this.$getIndent(line);\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        if (tokens.length && tokens[tokens.length - 1].type == \"comment\") {\n            return indent;\n        }\n        if (state == \"start\") {\n            var match = line.match(/^.*[\\{\\(\\[]\\s*$/);\n            var startingClassOrMethod = line.match(/^\\s*(class|def|module)\\s.*$/);\n            var startingDoBlock = line.match(/.*do(\\s*|\\s+\\|.*\\|\\s*)$/);\n            var startingConditional = line.match(/^\\s*(if|else|when)\\s*/);\n            if (match || startingClassOrMethod || startingDoBlock || startingConditional) {\n                indent += tab;\n            }\n        }\n        return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n        return /^\\s+(end|else)$/.test(line + input) || this.$outdent.checkOutdent(line, input);\n    };\n    this.autoOutdent = function (state, session, row) {\n        var line = session.getLine(row);\n        if (/}/.test(line))\n            return this.$outdent.autoOutdent(session, row);\n        var indent = this.$getIndent(line);\n        var prevLine = session.getLine(row - 1);\n        var prevIndent = this.$getIndent(prevLine);\n        var tab = session.getTabString();\n        if (prevIndent.length <= indent.length) {\n            if (indent.slice(-tab.length) == tab)\n                session.remove(new Range(row, indent.length - tab.length, row, indent.length));\n        }\n    };\n    this.$id = \"ace/mode/crystal\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/crystal\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n\n//# sourceURL=webpack://robot-karol-4/./node_modules/ace-builds/src-noconflict/mode-crystal.js?");

/***/ })

}]);