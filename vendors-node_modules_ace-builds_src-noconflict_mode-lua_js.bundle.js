/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkrobot_karol_4"] = self["webpackChunkrobot_karol_4"] || []).push([["vendors-node_modules_ace-builds_src-noconflict_mode-lua_js"],{

/***/ "./node_modules/ace-builds/src-noconflict/mode-lua.js":
/*!************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/mode-lua.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nace.define(\"ace/mode/lua_highlight_rules\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text_highlight_rules\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextHighlightRules = require(\"./text_highlight_rules\").TextHighlightRules;\nvar LuaHighlightRules = function () {\n    var keywords = (\"break|do|else|elseif|end|for|function|if|in|local|repeat|\" +\n        \"return|then|until|while|or|and|not\");\n    var builtinConstants = (\"true|false|nil|_G|_VERSION\");\n    var functions = (\n    \"string|xpcall|package|tostring|print|os|unpack|require|\" +\n        \"getfenv|setmetatable|next|assert|tonumber|io|rawequal|\" +\n        \"collectgarbage|getmetatable|module|rawset|math|debug|\" +\n        \"pcall|table|newproxy|type|coroutine|_G|select|gcinfo|\" +\n        \"pairs|rawget|loadstring|ipairs|_VERSION|dofile|setfenv|\" +\n        \"load|error|loadfile|\" +\n        \"sub|upper|len|gfind|rep|find|match|char|dump|gmatch|\" +\n        \"reverse|byte|format|gsub|lower|preload|loadlib|loaded|\" +\n        \"loaders|cpath|config|path|seeall|exit|setlocale|date|\" +\n        \"getenv|difftime|remove|time|clock|tmpname|rename|execute|\" +\n        \"lines|write|close|flush|open|output|type|read|stderr|\" +\n        \"stdin|input|stdout|popen|tmpfile|log|max|acos|huge|\" +\n        \"ldexp|pi|cos|tanh|pow|deg|tan|cosh|sinh|random|randomseed|\" +\n        \"frexp|ceil|floor|rad|abs|sqrt|modf|asin|min|mod|fmod|log10|\" +\n        \"atan2|exp|sin|atan|getupvalue|debug|sethook|getmetatable|\" +\n        \"gethook|setmetatable|setlocal|traceback|setfenv|getinfo|\" +\n        \"setupvalue|getlocal|getregistry|getfenv|setn|insert|getn|\" +\n        \"foreachi|maxn|foreach|concat|sort|remove|resume|yield|\" +\n        \"status|wrap|create|running|\" +\n        \"__add|__sub|__mod|__unm|__concat|__lt|__index|__call|__gc|__metatable|\" +\n        \"__mul|__div|__pow|__len|__eq|__le|__newindex|__tostring|__mode|__tonumber\");\n    var stdLibaries = (\"string|package|os|io|math|debug|table|coroutine\");\n    var deprecatedIn5152 = (\"setn|foreach|foreachi|gcinfo|log10|maxn\");\n    var keywordMapper = this.createKeywordMapper({\n        \"keyword\": keywords,\n        \"support.function\": functions,\n        \"keyword.deprecated\": deprecatedIn5152,\n        \"constant.library\": stdLibaries,\n        \"constant.language\": builtinConstants,\n        \"variable.language\": \"self\"\n    }, \"identifier\");\n    var decimalInteger = \"(?:(?:[1-9]\\\\d*)|(?:0))\";\n    var hexInteger = \"(?:0[xX][\\\\dA-Fa-f]+)\";\n    var integer = \"(?:\" + decimalInteger + \"|\" + hexInteger + \")\";\n    var fraction = \"(?:\\\\.\\\\d+)\";\n    var intPart = \"(?:\\\\d+)\";\n    var pointFloat = \"(?:(?:\" + intPart + \"?\" + fraction + \")|(?:\" + intPart + \"\\\\.))\";\n    var floatNumber = \"(?:\" + pointFloat + \")\";\n    this.$rules = {\n        \"start\": [{\n                stateName: \"bracketedComment\",\n                onMatch: function (value, currentState, stack) {\n                    stack.unshift(this.next, value.length - 2, currentState);\n                    return \"comment\";\n                },\n                regex: /\\-\\-\\[=*\\[/,\n                next: [\n                    {\n                        onMatch: function (value, currentState, stack) {\n                            if (value.length == stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack.shift();\n                            }\n                            else {\n                                this.next = \"\";\n                            }\n                            return \"comment\";\n                        },\n                        regex: /\\]=*\\]/,\n                        next: \"start\"\n                    }, {\n                        defaultToken: \"comment.body\"\n                    }\n                ]\n            },\n            {\n                token: \"comment\",\n                regex: \"\\\\-\\\\-.*$\"\n            },\n            {\n                stateName: \"bracketedString\",\n                onMatch: function (value, currentState, stack) {\n                    stack.unshift(this.next, value.length, currentState);\n                    return \"string.start\";\n                },\n                regex: /\\[=*\\[/,\n                next: [\n                    {\n                        onMatch: function (value, currentState, stack) {\n                            if (value.length == stack[1]) {\n                                stack.shift();\n                                stack.shift();\n                                this.next = stack.shift();\n                            }\n                            else {\n                                this.next = \"\";\n                            }\n                            return \"string.end\";\n                        },\n                        regex: /\\]=*\\]/,\n                        next: \"start\"\n                    }, {\n                        defaultToken: \"string\"\n                    }\n                ]\n            },\n            {\n                token: \"string\", // \" string\n                regex: '\"(?:[^\\\\\\\\]|\\\\\\\\.)*?\"'\n            }, {\n                token: \"string\", // ' string\n                regex: \"'(?:[^\\\\\\\\]|\\\\\\\\.)*?'\"\n            }, {\n                token: \"constant.numeric\", // float\n                regex: floatNumber\n            }, {\n                token: \"constant.numeric\", // integer\n                regex: integer + \"\\\\b\"\n            }, {\n                token: keywordMapper,\n                regex: \"[a-zA-Z_$][a-zA-Z0-9_$]*\\\\b\"\n            }, {\n                token: \"keyword.operator\",\n                regex: \"\\\\+|\\\\-|\\\\*|\\\\/|%|\\\\#|\\\\^|~|<|>|<=|=>|==|~=|=|\\\\:|\\\\.\\\\.\\\\.|\\\\.\\\\.\"\n            }, {\n                token: \"paren.lparen\",\n                regex: \"[\\\\[\\\\(\\\\{]\"\n            }, {\n                token: \"paren.rparen\",\n                regex: \"[\\\\]\\\\)\\\\}]\"\n            }, {\n                token: \"text\",\n                regex: \"\\\\s+|\\\\w+\"\n            }]\n    };\n    this.normalizeRules();\n};\noop.inherits(LuaHighlightRules, TextHighlightRules);\nexports.LuaHighlightRules = LuaHighlightRules;\n\n});\n\nace.define(\"ace/mode/folding/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/folding/fold_mode\",\"ace/range\",\"ace/token_iterator\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../../lib/oop\");\nvar BaseFoldMode = require(\"./fold_mode\").FoldMode;\nvar Range = require(\"../../range\").Range;\nvar TokenIterator = require(\"../../token_iterator\").TokenIterator;\nvar FoldMode = exports.FoldMode = function () { };\noop.inherits(FoldMode, BaseFoldMode);\n(function () {\n    this.foldingStartMarker = /\\b(function|then|do|repeat)\\b|{\\s*$|(\\[=*\\[)/;\n    this.foldingStopMarker = /\\bend\\b|^\\s*}|\\]=*\\]/;\n    this.getFoldWidget = function (session, foldStyle, row) {\n        var line = session.getLine(row);\n        var isStart = this.foldingStartMarker.test(line);\n        var isEnd = this.foldingStopMarker.test(line);\n        if (isStart && !isEnd) {\n            var match = line.match(this.foldingStartMarker);\n            if (match[1] == \"then\" && /\\belseif\\b/.test(line))\n                return;\n            if (match[1]) {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return \"start\";\n            }\n            else if (match[2]) {\n                var type = session.bgTokenizer.getState(row) || \"\";\n                if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                    return \"start\";\n            }\n            else {\n                return \"start\";\n            }\n        }\n        if (foldStyle != \"markbeginend\" || !isEnd || isStart && isEnd)\n            return \"\";\n        var match = line.match(this.foldingStopMarker);\n        if (match[0] === \"end\") {\n            if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                return \"end\";\n        }\n        else if (match[0][0] === \"]\") {\n            var type = session.bgTokenizer.getState(row - 1) || \"\";\n            if (type[0] == \"bracketedComment\" || type[0] == \"bracketedString\")\n                return \"end\";\n        }\n        else\n            return \"end\";\n    };\n    this.getFoldWidgetRange = function (session, foldStyle, row) {\n        var line = session.doc.getLine(row);\n        var match = this.foldingStartMarker.exec(line);\n        if (match) {\n            if (match[1])\n                return this.luaBlock(session, row, match.index + 1);\n            if (match[2])\n                return session.getCommentFoldRange(row, match.index + 1);\n            return this.openingBracketBlock(session, \"{\", row, match.index);\n        }\n        var match = this.foldingStopMarker.exec(line);\n        if (match) {\n            if (match[0] === \"end\") {\n                if (session.getTokenAt(row, match.index + 1).type === \"keyword\")\n                    return this.luaBlock(session, row, match.index + 1);\n            }\n            if (match[0][0] === \"]\")\n                return session.getCommentFoldRange(row, match.index + 1);\n            return this.closingBracketBlock(session, \"}\", row, match.index + match[0].length);\n        }\n    };\n    this.luaBlock = function (session, row, column, tokenRange) {\n        var stream = new TokenIterator(session, row, column);\n        var indentKeywords = {\n            \"function\": 1,\n            \"do\": 1,\n            \"then\": 1,\n            \"elseif\": -1,\n            \"end\": -1,\n            \"repeat\": 1,\n            \"until\": -1\n        };\n        var token = stream.getCurrentToken();\n        if (!token || token.type != \"keyword\")\n            return;\n        var val = token.value;\n        var stack = [val];\n        var dir = indentKeywords[val];\n        if (!dir)\n            return;\n        var startColumn = dir === -1 ? stream.getCurrentTokenColumn() : session.getLine(row).length;\n        var startRow = row;\n        stream.step = dir === -1 ? stream.stepBackward : stream.stepForward;\n        while (token = stream.step()) {\n            if (token.type !== \"keyword\")\n                continue;\n            var level = dir * indentKeywords[token.value];\n            if (level > 0) {\n                stack.unshift(token.value);\n            }\n            else if (level <= 0) {\n                stack.shift();\n                if (!stack.length && token.value != \"elseif\")\n                    break;\n                if (level === 0)\n                    stack.unshift(token.value);\n            }\n        }\n        if (!token)\n            return null;\n        if (tokenRange)\n            return stream.getCurrentTokenRange();\n        var row = stream.getCurrentTokenRow();\n        if (dir === -1)\n            return new Range(row, session.getLine(row).length, startRow, startColumn);\n        else\n            return new Range(startRow, startColumn, row, stream.getCurrentTokenColumn());\n    };\n}).call(FoldMode.prototype);\n\n});\n\nace.define(\"ace/mode/lua\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/mode/text\",\"ace/mode/lua_highlight_rules\",\"ace/mode/folding/lua\",\"ace/range\",\"ace/worker/worker_client\"], function(require, exports, module){\"use strict\";\nvar oop = require(\"../lib/oop\");\nvar TextMode = require(\"./text\").Mode;\nvar LuaHighlightRules = require(\"./lua_highlight_rules\").LuaHighlightRules;\nvar LuaFoldMode = require(\"./folding/lua\").FoldMode;\nvar Range = require(\"../range\").Range;\nvar WorkerClient = require(\"../worker/worker_client\").WorkerClient;\nvar Mode = function () {\n    this.HighlightRules = LuaHighlightRules;\n    this.foldingRules = new LuaFoldMode();\n    this.$behaviour = this.$defaultBehaviour;\n};\noop.inherits(Mode, TextMode);\n(function () {\n    this.lineCommentStart = \"--\";\n    this.blockComment = { start: \"--[[\", end: \"--]]\" };\n    var indentKeywords = {\n        \"function\": 1,\n        \"then\": 1,\n        \"do\": 1,\n        \"else\": 1,\n        \"elseif\": 1,\n        \"repeat\": 1,\n        \"end\": -1,\n        \"until\": -1\n    };\n    var outdentKeywords = [\n        \"else\",\n        \"elseif\",\n        \"end\",\n        \"until\"\n    ];\n    function getNetIndentLevel(tokens) {\n        var level = 0;\n        for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n            if (token.type == \"keyword\") {\n                if (token.value in indentKeywords) {\n                    level += indentKeywords[token.value];\n                }\n            }\n            else if (token.type == \"paren.lparen\") {\n                level += token.value.length;\n            }\n            else if (token.type == \"paren.rparen\") {\n                level -= token.value.length;\n            }\n        }\n        if (level < 0) {\n            return -1;\n        }\n        else if (level > 0) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    this.getNextLineIndent = function (state, line, tab) {\n        var indent = this.$getIndent(line);\n        var level = 0;\n        var tokenizedLine = this.getTokenizer().getLineTokens(line, state);\n        var tokens = tokenizedLine.tokens;\n        if (state == \"start\") {\n            level = getNetIndentLevel(tokens);\n        }\n        if (level > 0) {\n            return indent + tab;\n        }\n        else if (level < 0 && indent.substr(indent.length - tab.length) == tab) {\n            if (!this.checkOutdent(state, line, \"\\n\")) {\n                return indent.substr(0, indent.length - tab.length);\n            }\n        }\n        return indent;\n    };\n    this.checkOutdent = function (state, line, input) {\n        if (input != \"\\n\" && input != \"\\r\" && input != \"\\r\\n\")\n            return false;\n        if (line.match(/^\\s*[\\)\\}\\]]$/))\n            return true;\n        var tokens = this.getTokenizer().getLineTokens(line.trim(), state).tokens;\n        if (!tokens || !tokens.length)\n            return false;\n        return (tokens[0].type == \"keyword\" && outdentKeywords.indexOf(tokens[0].value) != -1);\n    };\n    this.getMatching = function (session, row, column) {\n        if (row == undefined) {\n            var pos = session.selection.lead;\n            column = pos.column;\n            row = pos.row;\n        }\n        var startToken = session.getTokenAt(row, column);\n        if (startToken && startToken.value in indentKeywords)\n            return this.foldingRules.luaBlock(session, row, column, true);\n    };\n    this.autoOutdent = function (state, session, row) {\n        var line = session.getLine(row);\n        var column = line.match(/^\\s*/)[0].length;\n        if (!column || !row)\n            return;\n        var startRange = this.getMatching(session, row, column + 1);\n        if (!startRange || startRange.start.row == row)\n            return;\n        var indent = this.$getIndent(session.getLine(startRange.start.row));\n        if (indent.length != column) {\n            session.replace(new Range(row, 0, row, column), indent);\n            session.outdentRows(new Range(row + 1, 0, row + 1, 0));\n        }\n    };\n    this.createWorker = function (session) {\n        var worker = new WorkerClient([\"ace\"], \"ace/mode/lua_worker\", \"Worker\");\n        worker.attachToDocument(session.getDocument());\n        worker.on(\"annotate\", function (e) {\n            session.setAnnotations(e.data);\n        });\n        worker.on(\"terminate\", function () {\n            session.clearAnnotations();\n        });\n        return worker;\n    };\n    this.$id = \"ace/mode/lua\";\n    this.snippetFileId = \"ace/snippets/lua\";\n}).call(Mode.prototype);\nexports.Mode = Mode;\n\n});                (function() {\n                    ace.require([\"ace/mode/lua\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n\n//# sourceURL=webpack://robot-karol-4/./node_modules/ace-builds/src-noconflict/mode-lua.js?");

/***/ })

}]);